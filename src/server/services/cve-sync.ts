// src/server/services/cve-sync.ts
import {
  PrismaClient,
  VulnerabilitySeverity,
  VulnerabilitySource,
} from "@prisma/client";

interface SentinelOneCVE {
  id: string;
  cveId: string;
  endpointId: string; // SentinelOne agent ID
  endpointName: string;
  application: string;
  applicationName: string;
  applicationVendor: string;
  applicationVersion: string;
  baseScore: string;
  cvssVersion: string;
  daysDetected: number;
  detectionDate: string;
  lastScanDate: string;
  lastScanResult: string;
  severity: "CRITICAL" | "HIGH" | "MEDIUM" | "LOW" | "INFO";
  status: string;
  publishedDate: string;
  endpointType: string;
  osType: string;
}

interface SentinelOneCVEResponse {
  data: SentinelOneCVE[];
  pagination: {
    totalItems: number;
    nextCursor: string | null;
  };
}

interface CVESyncResult {
  success: boolean;
  totalProcessed: number;
  vulnerabilitiesCreated: number;
  vulnerabilitiesUpdated: number;
  endpointVulnsCreated: number;
  endpointVulnsUpdated: number;
  endpointVulnsSkipped: number;
  unmappedEndpoints: string[];
  errors: string[];
  syncDetails: {
    startTime: Date;
    endTime: Date;
    durationMs: number;
    pagesProcessed: number;
    avgProcessingTimePerPage: number;
  };
}

export class CVESyncService {
  constructor(
    private readonly apiKey: string,
    private readonly endpoint: string,
    private readonly db: PrismaClient,
  ) {}

  /**
   * Main CVE sync function - processes all CVEs with pagination
   */
  async syncAllCVEs(
    progressCallback?: (progress: any) => void,
  ): Promise<CVESyncResult> {
    const startTime = new Date();
    console.log("üöÄ Starting comprehensive CVE sync...");

    // Build endpoint mapping first
    const endpointMapping = await this.buildEndpointMapping();
    console.log(
      `üìã Built mapping for ${Object.keys(endpointMapping).length} endpoints`,
    );

    let totalProcessed = 0;
    let vulnerabilitiesCreated = 0;
    let vulnerabilitiesUpdated = 0;
    let endpointVulnsCreated = 0;
    let endpointVulnsUpdated = 0;
    let endpointVulnsSkipped = 0;
    let pagesProcessed = 0;
    const unmappedEndpoints = new Set<string>();
    const errors: string[] = [];

    let cursor: string | null = null;
    const pageSize = 1000; // Max page size

    try {
      do {
        console.log(`üìÑ Processing page ${pagesProcessed + 1}...`);

        const pageResult = await this.fetchCVEPage(cursor, pageSize);
        if (!pageResult.success || !pageResult.data) {
          errors.push(
            `Failed to fetch page ${pagesProcessed + 1}: ${pageResult.error}`,
          );
          break;
        }

        const { data: cves, pagination } = pageResult.data;

        // Process this batch of CVEs
        const batchResult = await this.processCVEBatch(
          cves,
          endpointMapping,
          unmappedEndpoints,
        );

        // Update counters
        totalProcessed += cves.length;
        vulnerabilitiesCreated += batchResult.vulnerabilitiesCreated;
        vulnerabilitiesUpdated += batchResult.vulnerabilitiesUpdated;
        endpointVulnsCreated += batchResult.endpointVulnsCreated;
        endpointVulnsUpdated += batchResult.endpointVulnsUpdated;
        endpointVulnsSkipped += batchResult.endpointVulnsSkipped;
        pagesProcessed++;

        // Progress callback
        if (progressCallback) {
          progressCallback({
            totalProcessed,
            estimatedTotal: pagination.totalItems,
            currentPage: pagesProcessed,
            vulnerabilitiesCreated,
            endpointVulnsCreated,
            unmappedCount: unmappedEndpoints.size,
            completedPercentage: Math.round(
              (totalProcessed / pagination.totalItems) * 100,
            ),
          });
        }

        cursor = pagination.nextCursor;

        // Brief pause between pages to avoid rate limiting
        await new Promise((resolve) => setTimeout(resolve, 100));
      } while (cursor);
    } catch (error) {
      console.error("‚ùå CVE sync failed:", error);
      errors.push(`Sync failed: ${error}`);
    }

    const endTime = new Date();
    const durationMs = endTime.getTime() - startTime.getTime();

    const result: CVESyncResult = {
      success: errors.length === 0,
      totalProcessed,
      vulnerabilitiesCreated,
      vulnerabilitiesUpdated,
      endpointVulnsCreated,
      endpointVulnsUpdated,
      endpointVulnsSkipped,
      unmappedEndpoints: Array.from(unmappedEndpoints),
      errors,
      syncDetails: {
        startTime,
        endTime,
        durationMs,
        pagesProcessed,
        avgProcessingTimePerPage:
          pagesProcessed > 0 ? durationMs / pagesProcessed : 0,
      },
    };

    console.log("üéâ CVE sync completed:", {
      processed: totalProcessed,
      vulnerabilities: `${vulnerabilitiesCreated} created, ${vulnerabilitiesUpdated} updated`,
      endpointVulns: `${endpointVulnsCreated} created, ${endpointVulnsUpdated} updated, ${endpointVulnsSkipped} skipped`,
      unmapped: unmappedEndpoints.size,
      duration: `${Math.round(durationMs / 1000)}s`,
    });

    return result;
  }

  /**
   * Build mapping from SentinelOne endpoint IDs to our internal endpoint IDs
   */
  private async buildEndpointMapping(): Promise<
    Record<string, { endpointId: string; tenantId: string }>
  > {
    const endpoints = await this.db.endpoint.findMany({
      where: {
        sentinelOneAgentId: { not: null },
      },
      select: {
        id: true,
        tenantId: true,
        sentinelOneAgentId: true,
        hostname: true,
      },
    });

    const mapping: Record<string, { endpointId: string; tenantId: string }> =
      {};

    endpoints.forEach((endpoint) => {
      if (endpoint.sentinelOneAgentId) {
        mapping[endpoint.sentinelOneAgentId] = {
          endpointId: endpoint.id,
          tenantId: endpoint.tenantId,
        };
      }
    });

    return mapping;
  }

  /**
   * Fetch a single page of CVE data from SentinelOne
   */
  private async fetchCVEPage(
    cursor: string | null,
    limit: number,
  ): Promise<{
    success: boolean;
    data?: SentinelOneCVEResponse;
    error?: string;
  }> {
    try {
      const params = new URLSearchParams({
        limit: limit.toString(),
        sortby: "id",
        sortorder: "asc",
      });

      if (cursor) {
        params.append("cursor", cursor);
      }

      const response = await fetch(
        `${this.endpoint}/web/api/v2.1/application-management/risks?${params}`,
        {
          headers: {
            Authorization: `ApiToken ${this.apiKey}`,
            "Content-Type": "application/json",
            Accept: "application/json",
          },
        },
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        return {
          success: false,
          error: `HTTP ${response.status}: ${errorData.message || response.statusText}`,
        };
      }

      const data = await response.json();
      return { success: true, data };
    } catch (error) {
      return {
        success: false,
        error: `Request failed: ${error}`,
      };
    }
  }

  /**
   * Process a batch of CVEs
   */
  private async processCVEBatch(
    cves: SentinelOneCVE[],
    endpointMapping: Record<string, { endpointId: string; tenantId: string }>,
    unmappedEndpoints: Set<string>,
  ): Promise<{
    vulnerabilitiesCreated: number;
    vulnerabilitiesUpdated: number;
    endpointVulnsCreated: number;
    endpointVulnsUpdated: number;
    endpointVulnsSkipped: number;
  }> {
    let vulnerabilitiesCreated = 0;
    let vulnerabilitiesUpdated = 0;
    let endpointVulnsCreated = 0;
    let endpointVulnsUpdated = 0;
    let endpointVulnsSkipped = 0;

    // Group CVEs by CVE ID to avoid duplicate vulnerability records
    const cveGroups = this.groupCVEsByCveId(cves);

    for (const [cveId, cveInstances] of Object.entries(cveGroups)) {
      try {
        // Create or update the vulnerability record
        const vulnerability = await this.upsertVulnerability(
          cveId,
          cveInstances[0],
        );

        if (vulnerability.created) {
          vulnerabilitiesCreated++;
        } else {
          vulnerabilitiesUpdated++;
        }

        // Process each endpoint instance of this CVE
        for (const cve of cveInstances) {
          const endpointInfo = endpointMapping[cve.endpointId];

          if (!endpointInfo) {
            unmappedEndpoints.add(cve.endpointId);
            endpointVulnsSkipped++;
            continue;
          }

          const endpointVuln = await this.upsertEndpointVulnerability(
            endpointInfo.endpointId,
            vulnerability.id,
            cve,
          );

          if (endpointVuln.created) {
            endpointVulnsCreated++;
          } else {
            endpointVulnsUpdated++;
          }
        }
      } catch (error) {
        console.error(`‚ùå Failed to process CVE ${cveId}:`, error);
        endpointVulnsSkipped += cveInstances.length;
      }
    }

    return {
      vulnerabilitiesCreated,
      vulnerabilitiesUpdated,
      endpointVulnsCreated,
      endpointVulnsUpdated,
      endpointVulnsSkipped,
    };
  }

  /**
   * Group CVEs by CVE ID to handle the same vulnerability on multiple endpoints
   */
  private groupCVEsByCveId(
    cves: SentinelOneCVE[],
  ): Record<string, SentinelOneCVE[]> {
    return cves.reduce(
      (groups, cve) => {
        if (!groups[cve.cveId]) {
          groups[cve.cveId] = [];
        }
        groups[cve.cveId].push(cve);
        return groups;
      },
      {} as Record<string, SentinelOneCVE[]>,
    );
  }

  /**
   * Create or update a vulnerability record
   */
  private async upsertVulnerability(
    cveId: string,
    cve: SentinelOneCVE,
  ): Promise<{
    id: string;
    created: boolean;
  }> {
    const severity = this.mapSeverity(cve.severity);
    const cvssScore = parseFloat(cve.baseScore) || null;

    const vulnerability = await this.db.vulnerability.upsert({
      where: { cveId },
      update: {
        severity,
        cvssScore,
        vendor: cve.applicationVendor,
        product: cve.applicationName,
        version: cve.applicationVersion,
        updatedAt: new Date(),
      },
      create: {
        cveId,
        title: `${cve.applicationName} ${cve.applicationVersion} - ${cveId}`,
        description: `${cve.severity} severity vulnerability in ${cve.application}`,
        severity,
        cvssScore,
        vendor: cve.applicationVendor,
        product: cve.applicationName,
        version: cve.applicationVersion,
      },
    });

    // Check if this was created or updated
    const existing = await this.db.vulnerability.findUnique({
      where: { cveId },
      select: { createdAt: true, updatedAt: true },
    });

    const created =
      existing?.createdAt.getTime() === existing?.updatedAt.getTime();

    return { id: vulnerability.id, created };
  }

  /**
   * Create or update endpoint vulnerability relationship
   */
  private async upsertEndpointVulnerability(
    endpointId: string,
    vulnerabilityId: string,
    cve: SentinelOneCVE,
  ): Promise<{ created: boolean }> {
    const detectedAt = new Date(cve.detectionDate);

    const existing = await this.db.endpointVulnerability.findUnique({
      where: {
        endpointId_vulnerabilityId: {
          endpointId,
          vulnerabilityId,
        },
      },
    });

    if (existing) {
      // Update existing record
      await this.db.endpointVulnerability.update({
        where: { id: existing.id },
        data: {
          detectedAt,
          status: cve.status === "Detected" ? "OPEN" : "RESOLVED",
        },
      });
      return { created: false };
    } else {
      // Create new record
      await this.db.endpointVulnerability.create({
        data: {
          endpointId,
          vulnerabilityId,
          detectedBy: VulnerabilitySource.SENTINELONE,
          detectedAt,
          status: cve.status === "Detected" ? "OPEN" : "RESOLVED",
        },
      });
      return { created: true };
    }
  }

  /**
   * Update endpoint vulnerability counts
   */
  async updateEndpointVulnerabilityCounts(): Promise<void> {
    console.log("üìä Updating endpoint vulnerability counts...");

    const endpoints = await this.db.endpoint.findMany({
      include: {
        vulnerabilities: {
          include: {
            vulnerability: true,
          },
          where: {
            status: "OPEN",
          },
        },
      },
    });

    for (const endpoint of endpoints) {
      const counts = {
        criticalVulns: 0,
        highVulns: 0,
        mediumVulns: 0,
        lowVulns: 0,
      };

      endpoint.vulnerabilities.forEach((ev) => {
        switch (ev.vulnerability.severity) {
          case VulnerabilitySeverity.CRITICAL:
            counts.criticalVulns++;
            break;
          case VulnerabilitySeverity.HIGH:
            counts.highVulns++;
            break;
          case VulnerabilitySeverity.MEDIUM:
            counts.mediumVulns++;
            break;
          case VulnerabilitySeverity.LOW:
            counts.lowVulns++;
            break;
        }
      });

      await this.db.endpoint.update({
        where: { id: endpoint.id },
        data: counts,
      });
    }

    console.log(
      `‚úÖ Updated vulnerability counts for ${endpoints.length} endpoints`,
    );
  }

  /**
   * Map SentinelOne severity to our enum
   */
  private mapSeverity(severity: string): VulnerabilitySeverity {
    switch (severity?.toUpperCase()) {
      case "CRITICAL":
        return VulnerabilitySeverity.CRITICAL;
      case "HIGH":
        return VulnerabilitySeverity.HIGH;
      case "MEDIUM":
        return VulnerabilitySeverity.MEDIUM;
      case "LOW":
        return VulnerabilitySeverity.LOW;
      default:
        return VulnerabilitySeverity.INFO;
    }
  }

  /**
   * Get sync statistics
   */
  async getSyncStatistics(): Promise<{
    totalVulnerabilities: number;
    totalEndpointVulnerabilities: number;
    vulnerabilitiesBySeverity: Record<string, number>;
    recentlyDetected: number;
    unmappedEndpoints: number;
  }> {
    const [
      totalVulnerabilities,
      totalEndpointVulnerabilities,
      vulnerabilitiesBySeverity,
      recentlyDetected,
    ] = await Promise.all([
      this.db.vulnerability.count(),
      this.db.endpointVulnerability.count({ where: { status: "OPEN" } }),
      this.db.vulnerability.groupBy({
        by: ["severity"],
        _count: true,
      }),
      this.db.endpointVulnerability.count({
        where: {
          detectedAt: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // Last 7 days
          },
          status: "OPEN",
        },
      }),
    ]);

    const severityMap = vulnerabilitiesBySeverity.reduce(
      (acc, item) => {
        acc[item.severity] = item._count;
        return acc;
      },
      {} as Record<string, number>,
    );

    return {
      totalVulnerabilities,
      totalEndpointVulnerabilities,
      vulnerabilitiesBySeverity: severityMap,
      recentlyDetected,
      unmappedEndpoints: 0, // Would need to track this separately
    };
  }
}
