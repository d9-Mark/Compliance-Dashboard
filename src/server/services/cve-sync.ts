// src/server/services/cve-sync.ts
// FIXED VERSION with proper pagination, rate limiting, and 429 handling

import {
  PrismaClient,
  VulnerabilitySeverity,
  VulnerabilitySource,
} from "@prisma/client";

interface SentinelOneCVE {
  id: string;
  cveId: string;
  endpointId: string; // SentinelOne agent ID
  endpointName: string;
  application: string;
  applicationName: string;
  applicationVendor: string;
  applicationVersion: string;
  baseScore: string;
  cvssVersion: string;
  daysDetected: number;
  detectionDate: string;
  lastScanDate: string;
  lastScanResult: string;
  severity: "CRITICAL" | "HIGH" | "MEDIUM" | "LOW" | "INFO";
  status: string;
  publishedDate: string;
  endpointType: string;
  osType: string;
}

interface SentinelOneCVEResponse {
  data: SentinelOneCVE[];
  pagination: {
    totalItems?: number; // May not be present in all responses
    nextCursor: string | null;
  };
}

interface CVESyncResult {
  success: boolean;
  totalProcessed: number;
  vulnerabilitiesCreated: number;
  vulnerabilitiesUpdated: number;
  endpointVulnsCreated: number;
  endpointVulnsUpdated: number;
  endpointVulnsSkipped: number;
  unmappedEndpoints: string[];
  errors: string[];
  syncDetails: {
    startTime: Date;
    endTime: Date;
    durationMs: number;
    pagesProcessed: number;
    avgProcessingTimePerPage: number;
    totalItemsFromAPI: number;
    rateLimit429Count: number;
  };
}

export class CVESyncService {
  private readonly maxRetries = 5;
  private readonly baseDelay = 1000; // 1 second base delay
  private readonly maxDelay = 60000; // 60 second max delay

  constructor(
    private readonly apiKey: string,
    private readonly endpoint: string,
    private readonly db: PrismaClient,
  ) {}

  /**
   * Main CVE sync function - processes all CVEs with pagination
   */
  async syncAllCVEs(
    progressCallback?: (progress: any) => void,
  ): Promise<CVESyncResult> {
    const startTime = new Date();
    console.log("🚀 Starting comprehensive CVE sync...");

    // Build endpoint mapping first
    const endpointMapping = await this.buildEndpointMapping();
    console.log(
      `📋 Built mapping for ${Object.keys(endpointMapping).length} endpoints`,
    );

    let totalProcessed = 0;
    let vulnerabilitiesCreated = 0;
    let vulnerabilitiesUpdated = 0;
    let endpointVulnsCreated = 0;
    let endpointVulnsUpdated = 0;
    let endpointVulnsSkipped = 0;
    let pagesProcessed = 0;
    let rateLimit429Count = 0;
    let totalItemsFromAPI = 0; // Cache this from first request
    const unmappedEndpoints = new Set<string>();
    const errors: string[] = [];

    let cursor: string | null = null;
    const pageSize = 500; // Reduced from 1000 to be more conservative with rate limits

    try {
      do {
        console.log(`📄 Processing page ${pagesProcessed + 1}...`);

        const pageResult = await this.fetchCVEPageWithRetry(cursor, pageSize);
        if (!pageResult.success || !pageResult.data) {
          errors.push(
            `Failed to fetch page ${pagesProcessed + 1}: ${pageResult.error}`,
          );
          break;
        }

        const { data: cves, pagination } = pageResult.data;

        // FIXED: Cache totalItems from first response
        if (pagesProcessed === 0 && pagination.totalItems) {
          totalItemsFromAPI = pagination.totalItems;
          console.log(
            `📈 Total items to process: ${totalItemsFromAPI.toLocaleString()}`,
          );
        }

        // Track rate limit hits
        if (pageResult.rateLimitHit) {
          rateLimit429Count++;
        }

        // Process this batch of CVEs
        const batchResult = await this.processCVEBatch(
          cves,
          endpointMapping,
          unmappedEndpoints,
        );

        // Update counters
        totalProcessed += cves.length;
        vulnerabilitiesCreated += batchResult.vulnerabilitiesCreated;
        vulnerabilitiesUpdated += batchResult.vulnerabilitiesUpdated;
        endpointVulnsCreated += batchResult.endpointVulnsCreated;
        endpointVulnsUpdated += batchResult.endpointVulnsUpdated;
        endpointVulnsSkipped += batchResult.endpointVulnsSkipped;
        pagesProcessed++;

        // Progress callback with FIXED percentage calculation
        if (progressCallback) {
          const estimatedTotal = totalItemsFromAPI || totalProcessed; // Fallback to current count
          const completedPercentage =
            estimatedTotal > 0
              ? Math.round((totalProcessed / estimatedTotal) * 100)
              : 0; // Prevent infinity

          progressCallback({
            totalProcessed,
            estimatedTotal,
            currentPage: pagesProcessed,
            vulnerabilitiesCreated,
            endpointVulnsCreated,
            unmappedCount: unmappedEndpoints.size,
            completedPercentage,
            rateLimit429Count,
          });
        }

        cursor = pagination.nextCursor;

        // Dynamic delay based on progress and rate limits
        const delay = this.calculateDelay(rateLimit429Count, pagesProcessed);
        if (delay > 0) {
          console.log(`⏳ Waiting ${delay}ms before next request...`);
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      } while (cursor);
    } catch (error) {
      console.error("❌ CVE sync failed:", error);
      errors.push(`Sync failed: ${error}`);
    }

    const endTime = new Date();
    const durationMs = endTime.getTime() - startTime.getTime();

    const result: CVESyncResult = {
      success: errors.length === 0,
      totalProcessed,
      vulnerabilitiesCreated,
      vulnerabilitiesUpdated,
      endpointVulnsCreated,
      endpointVulnsUpdated,
      endpointVulnsSkipped,
      unmappedEndpoints: Array.from(unmappedEndpoints),
      errors,
      syncDetails: {
        startTime,
        endTime,
        durationMs,
        pagesProcessed,
        avgProcessingTimePerPage:
          pagesProcessed > 0 ? durationMs / pagesProcessed : 0,
        totalItemsFromAPI,
        rateLimit429Count,
      },
    };

    console.log("🎉 CVE sync completed:", {
      processed: totalProcessed,
      estimatedTotal: totalItemsFromAPI,
      vulnerabilities: `${vulnerabilitiesCreated} created, ${vulnerabilitiesUpdated} updated`,
      endpointVulns: `${endpointVulnsCreated} created, ${endpointVulnsUpdated} updated, ${endpointVulnsSkipped} skipped`,
      unmapped: unmappedEndpoints.size,
      duration: `${Math.round(durationMs / 1000)}s`,
      rateLimitHits: rateLimit429Count,
    });

    return result;
  }

  /**
   * Calculate delay between requests based on rate limit history
   */
  private calculateDelay(
    rateLimitCount: number,
    pagesProcessed: number,
  ): number {
    // Start with base delay
    let delay = this.baseDelay;

    // Increase delay if we've hit rate limits
    if (rateLimitCount > 0) {
      delay = Math.min(delay * Math.pow(2, rateLimitCount), this.maxDelay);
    }

    // Add some jitter to avoid thundering herd
    delay += Math.random() * 500;

    // Reduce delay as we progress (API might be less loaded)
    if (pagesProcessed > 10 && rateLimitCount === 0) {
      delay = Math.max(500, delay * 0.8);
    }

    return Math.round(delay);
  }

  /**
   * Fetch CVE page with retry logic for 429 responses
   */
  private async fetchCVEPageWithRetry(
    cursor: string | null,
    limit: number,
  ): Promise<{
    success: boolean;
    data?: SentinelOneCVEResponse;
    error?: string;
    rateLimitHit?: boolean;
  }> {
    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      const result = await this.fetchCVEPage(cursor, limit);

      if (result.success) {
        return result;
      }

      // Check if it's a rate limit error
      if (
        result.error?.includes("429") ||
        result.error?.toLowerCase().includes("rate limit")
      ) {
        console.warn(
          `⏳ Rate limited (attempt ${attempt}/${this.maxRetries}), backing off...`,
        );

        if (attempt < this.maxRetries) {
          // Exponential backoff for rate limits
          const delay = Math.min(
            this.baseDelay * Math.pow(2, attempt - 1),
            this.maxDelay,
          );
          console.log(`⏳ Waiting ${delay}ms before retry...`);
          await new Promise((resolve) => setTimeout(resolve, delay));
          continue;
        } else {
          return { ...result, rateLimitHit: true };
        }
      }

      // For other errors, don't retry as aggressively
      if (attempt === this.maxRetries) {
        return result;
      }

      // Brief delay before retrying other errors
      await new Promise((resolve) => setTimeout(resolve, 1000));
    }

    return {
      success: false,
      error: "Max retries exceeded",
    };
  }

  /**
   * Fetch a single page of CVE data from SentinelOne
   */
  private async fetchCVEPage(
    cursor: string | null,
    limit: number,
  ): Promise<{
    success: boolean;
    data?: SentinelOneCVEResponse;
    error?: string;
  }> {
    try {
      const params = new URLSearchParams({
        limit: limit.toString(),
        sortBy: "id",
        sortOrder: "asc",
      });

      if (cursor) {
        params.append("cursor", cursor);
      }

      const response = await fetch(
        `${this.endpoint}/web/api/v2.1/application-management/risks?${params}`,
        {
          headers: {
            Authorization: `ApiToken ${this.apiKey}`,
            "Content-Type": "application/json",
            Accept: "application/json",
          },
          // Add timeout to prevent hanging requests
          signal: AbortSignal.timeout(60000), // 60 second timeout
        },
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        return {
          success: false,
          error: `HTTP ${response.status}: ${errorData.message || response.statusText}`,
        };
      }

      const data = await response.json();

      // Validate response structure
      if (!data.data || !Array.isArray(data.data)) {
        return {
          success: false,
          error: "Invalid response structure: missing data array",
        };
      }

      return { success: true, data };
    } catch (error) {
      // Handle timeout and other fetch errors
      if (error.name === "TimeoutError") {
        return {
          success: false,
          error: "Request timeout (60s)",
        };
      }

      return {
        success: false,
        error: `Request failed: ${error}`,
      };
    }
  }

  /**
   * Build mapping from SentinelOne endpoint IDs to our internal endpoint IDs
   */
  private async buildEndpointMapping(): Promise<
    Record<string, { endpointId: string; tenantId: string }>
  > {
    const endpoints = await this.db.endpoint.findMany({
      where: {
        sentinelOneAgentId: { not: null },
      },
      select: {
        id: true,
        tenantId: true,
        sentinelOneAgentId: true,
        hostname: true,
      },
    });

    const mapping: Record<string, { endpointId: string; tenantId: string }> =
      {};

    endpoints.forEach((endpoint) => {
      if (endpoint.sentinelOneAgentId) {
        mapping[endpoint.sentinelOneAgentId] = {
          endpointId: endpoint.id,
          tenantId: endpoint.tenantId,
        };
      }
    });

    return mapping;
  }

  /**
   * Process a batch of CVEs
   */
  private async processCVEBatch(
    cves: SentinelOneCVE[],
    endpointMapping: Record<string, { endpointId: string; tenantId: string }>,
    unmappedEndpoints: Set<string>,
  ): Promise<{
    vulnerabilitiesCreated: number;
    vulnerabilitiesUpdated: number;
    endpointVulnsCreated: number;
    endpointVulnsUpdated: number;
    endpointVulnsSkipped: number;
  }> {
    let vulnerabilitiesCreated = 0;
    let vulnerabilitiesUpdated = 0;
    let endpointVulnsCreated = 0;
    let endpointVulnsUpdated = 0;
    let endpointVulnsSkipped = 0;

    // Group CVEs by CVE ID to avoid duplicate vulnerability records
    const cveGroups = this.groupCVEsByCveId(cves);

    for (const [cveId, cveInstances] of Object.entries(cveGroups)) {
      try {
        // Create or update the vulnerability record
        const vulnerability = await this.upsertVulnerability(
          cveId,
          cveInstances[0],
        );

        if (vulnerability.created) {
          vulnerabilitiesCreated++;
        } else {
          vulnerabilitiesUpdated++;
        }

        // Process each endpoint instance of this CVE
        for (const cve of cveInstances) {
          const endpointInfo = endpointMapping[cve.endpointId];

          if (!endpointInfo) {
            unmappedEndpoints.add(cve.endpointId);
            endpointVulnsSkipped++;
            continue;
          }

          const endpointVuln = await this.upsertEndpointVulnerability(
            endpointInfo.endpointId,
            vulnerability.id,
            cve,
          );

          if (endpointVuln.created) {
            endpointVulnsCreated++;
          } else {
            endpointVulnsUpdated++;
          }
        }
      } catch (error) {
        console.error(`❌ Failed to process CVE ${cveId}:`, error);
        endpointVulnsSkipped += cveInstances.length;
      }
    }

    return {
      vulnerabilitiesCreated,
      vulnerabilitiesUpdated,
      endpointVulnsCreated,
      endpointVulnsUpdated,
      endpointVulnsSkipped,
    };
  }

  /**
   * Group CVEs by CVE ID to handle the same vulnerability on multiple endpoints
   */
  private groupCVEsByCveId(
    cves: SentinelOneCVE[],
  ): Record<string, SentinelOneCVE[]> {
    return cves.reduce(
      (groups, cve) => {
        if (!groups[cve.cveId]) {
          groups[cve.cveId] = [];
        }
        groups[cve.cveId].push(cve);
        return groups;
      },
      {} as Record<string, SentinelOneCVE[]>,
    );
  }

  /**
   * Create or update a vulnerability record
   */
  private async upsertVulnerability(
    cveId: string,
    cve: SentinelOneCVE,
  ): Promise<{
    id: string;
    created: boolean;
  }> {
    const severity = this.mapSeverity(cve.severity);
    const cvssScore = parseFloat(cve.baseScore) || null;

    const vulnerability = await this.db.vulnerability.upsert({
      where: { cveId },
      update: {
        severity,
        cvssScore,
        vendor: cve.applicationVendor,
        product: cve.applicationName,
        version: cve.applicationVersion,
        updatedAt: new Date(),
      },
      create: {
        cveId,
        title: `${cve.applicationName} ${cve.applicationVersion} - ${cveId}`,
        description: `${cve.severity} severity vulnerability in ${cve.application}`,
        severity,
        cvssScore,
        vendor: cve.applicationVendor,
        product: cve.applicationName,
        version: cve.applicationVersion,
      },
    });

    // Check if this was created or updated
    const existing = await this.db.vulnerability.findUnique({
      where: { cveId },
      select: { createdAt: true, updatedAt: true },
    });

    const created =
      existing?.createdAt.getTime() === existing?.updatedAt.getTime();

    return { id: vulnerability.id, created };
  }

  /**
   * Create or update endpoint vulnerability relationship
   */
  private async upsertEndpointVulnerability(
    endpointId: string,
    vulnerabilityId: string,
    cve: SentinelOneCVE,
  ): Promise<{ created: boolean }> {
    const detectedAt = new Date(cve.detectionDate);

    const existing = await this.db.endpointVulnerability.findUnique({
      where: {
        endpointId_vulnerabilityId: {
          endpointId,
          vulnerabilityId,
        },
      },
    });

    if (existing) {
      // Update existing record
      await this.db.endpointVulnerability.update({
        where: { id: existing.id },
        data: {
          detectedAt,
          status: cve.status === "Detected" ? "OPEN" : "RESOLVED",
        },
      });
      return { created: false };
    } else {
      // Create new record
      await this.db.endpointVulnerability.create({
        data: {
          endpointId,
          vulnerabilityId,
          detectedBy: VulnerabilitySource.SENTINELONE,
          detectedAt,
          status: cve.status === "Detected" ? "OPEN" : "RESOLVED",
        },
      });
      return { created: true };
    }
  }

  /**
   * Update endpoint vulnerability counts
   */
  async updateEndpointVulnerabilityCounts(): Promise<void> {
    console.log("📊 Updating endpoint vulnerability counts...");

    const endpoints = await this.db.endpoint.findMany({
      include: {
        vulnerabilities: {
          include: {
            vulnerability: true,
          },
          where: {
            status: "OPEN",
          },
        },
      },
    });

    for (const endpoint of endpoints) {
      const counts = {
        criticalVulns: 0,
        highVulns: 0,
        mediumVulns: 0,
        lowVulns: 0,
      };

      endpoint.vulnerabilities.forEach((ev) => {
        switch (ev.vulnerability.severity) {
          case VulnerabilitySeverity.CRITICAL:
            counts.criticalVulns++;
            break;
          case VulnerabilitySeverity.HIGH:
            counts.highVulns++;
            break;
          case VulnerabilitySeverity.MEDIUM:
            counts.mediumVulns++;
            break;
          case VulnerabilitySeverity.LOW:
            counts.lowVulns++;
            break;
        }
      });

      await this.db.endpoint.update({
        where: { id: endpoint.id },
        data: counts,
      });
    }

    console.log(
      `✅ Updated vulnerability counts for ${endpoints.length} endpoints`,
    );
  }

  /**
   * Map SentinelOne severity to our enum
   */
  private mapSeverity(severity: string): VulnerabilitySeverity {
    switch (severity?.toUpperCase()) {
      case "CRITICAL":
        return VulnerabilitySeverity.CRITICAL;
      case "HIGH":
        return VulnerabilitySeverity.HIGH;
      case "MEDIUM":
        return VulnerabilitySeverity.MEDIUM;
      case "LOW":
        return VulnerabilitySeverity.LOW;
      default:
        return VulnerabilitySeverity.INFO;
    }
  }

  /**
   * Get sync statistics
   */
  async getSyncStatistics(): Promise<{
    totalVulnerabilities: number;
    totalEndpointVulnerabilities: number;
    vulnerabilitiesBySeverity: Record<string, number>;
    recentlyDetected: number;
  }> {
    const [
      totalVulnerabilities,
      totalEndpointVulnerabilities,
      severityStats,
      recentlyDetected,
    ] = await Promise.all([
      this.db.vulnerability.count(),
      this.db.endpointVulnerability.count(),
      this.db.vulnerability.groupBy({
        by: ["severity"],
        _count: true,
      }),
      this.db.endpointVulnerability.count({
        where: {
          detectedAt: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // Last 7 days
          },
        },
      }),
    ]);

    const vulnerabilitiesBySeverity = severityStats.reduce(
      (acc, stat) => {
        acc[stat.severity] = stat._count;
        return acc;
      },
      {} as Record<string, number>,
    );

    return {
      totalVulnerabilities,
      totalEndpointVulnerabilities,
      vulnerabilitiesBySeverity,
      recentlyDetected,
    };
  }
}
