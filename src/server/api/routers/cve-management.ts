// src/server/api/routers/cve-management.ts - FIXED VERSION
import { z } from "zod";
import { createTRPCRouter, adminProcedure, tenantProcedure } from "../trpc";
import { CVESyncService } from "../../services/cve-sync";
import { env } from "../../../env";
import { VulnerabilitySeverity } from "@prisma/client";

export const cveManagementRouter = createTRPCRouter({
  // Admin-only CVE sync operation
  syncAllCVEs: adminProcedure.mutation(async ({ ctx }) => {
    if (!env.SENTINELONE_API_KEY || !env.SENTINELONE_ENDPOINT) {
      throw new Error(
        "SentinelOne configuration missing. Check environment variables.",
      );
    }

    console.log("🚀 Starting CVE sync operation...");

    const cveService = new CVESyncService(
      env.SENTINELONE_API_KEY,
      env.SENTINELONE_ENDPOINT,
      ctx.db,
    );

    try {
      const result = await cveService.syncAllCVEs((progress) => {
        console.log(
          `📊 CVE Sync Progress: ${progress.completedPercentage}% (${progress.totalProcessed}/${progress.estimatedTotal})`,
        );
      });

      // Update endpoint vulnerability counts after sync
      await cveService.updateEndpointVulnerabilityCounts();

      console.log("✅ CVE sync completed successfully");
      return result;
    } catch (error) {
      console.error("❌ CVE sync failed:", error);
      throw new Error(`CVE sync failed: ${error}`);
    }
  }),

  // Get CVE sync statistics
  getSyncStatistics: adminProcedure.query(async ({ ctx }) => {
    if (!env.SENTINELONE_API_KEY || !env.SENTINELONE_ENDPOINT) {
      throw new Error("SentinelOne configuration missing");
    }

    const cveService = new CVESyncService(
      env.SENTINELONE_API_KEY,
      env.SENTINELONE_ENDPOINT,
      ctx.db,
    );

    return await cveService.getSyncStatistics();
  }),

  // FIXED: Get vulnerabilities with proper tenant filtering
  getVulnerabilities: tenantProcedure
    .input(
      z.object({
        tenantId: z.string().optional(),
        severity: z.nativeEnum(VulnerabilitySeverity).optional(),
        limit: z.number().min(1).max(100).default(50),
        offset: z.number().min(0).default(0),
        search: z.string().optional(),
        status: z.enum(["OPEN", "RESOLVED", "ALL"]).default("OPEN"),
      }),
    )
    .query(async ({ ctx, input }) => {
      // FIXED: Determine the actual tenant ID to use
      let filterTenantId: string | undefined;

      if (ctx.isAdmin) {
        // Admin can specify a tenant or see all
        filterTenantId = input.tenantId;
      } else {
        // Regular users can only see their own tenant
        if (input.tenantId && input.tenantId !== ctx.tenantId) {
          throw new Error("Unauthorized: Cannot access other tenant's data");
        }
        filterTenantId = ctx.tenantId || undefined;
      }

      // FIXED: Build the where clause properly
      const whereClause: any = {};

      // Only filter by tenant if we have a specific tenant ID
      if (filterTenantId) {
        whereClause.endpoint = {
          tenantId: filterTenantId,
        };
      }

      // Add vulnerability filters
      if (input.severity) {
        whereClause.vulnerability = {
          ...(whereClause.vulnerability || {}),
          severity: input.severity,
        };
      }

      if (input.status !== "ALL") {
        whereClause.status = input.status;
      }

      if (input.search) {
        whereClause.vulnerability = {
          ...(whereClause.vulnerability || {}),
          OR: [
            { cveId: { contains: input.search, mode: "insensitive" } },
            { title: { contains: input.search, mode: "insensitive" } },
            { vendor: { contains: input.search, mode: "insensitive" } },
            { product: { contains: input.search, mode: "insensitive" } },
          ],
        };
      }

      try {
        const [vulnerabilities, total] = await Promise.all([
          ctx.db.endpointVulnerability.findMany({
            where: whereClause,
            include: {
              vulnerability: true,
              endpoint: {
                select: {
                  id: true,
                  hostname: true,
                  operatingSystem: true,
                  tenantId: true,
                },
              },
            },
            orderBy: [
              { vulnerability: { severity: "desc" } },
              { detectedAt: "desc" },
            ],
            take: input.limit,
            skip: input.offset,
          }),
          ctx.db.endpointVulnerability.count({
            where: whereClause,
          }),
        ]);

        return {
          vulnerabilities,
          total,
          hasMore: input.offset + input.limit < total,
        };
      } catch (error) {
        console.error("Error fetching vulnerabilities:", error);
        throw new Error(`Failed to fetch vulnerabilities: ${error}`);
      }
    }),

  // FIXED: Get vulnerability summary for tenant dashboard
  getVulnerabilitySummary: tenantProcedure
    .input(
      z.object({
        tenantId: z.string().optional(),
      }),
    )
    .query(async ({ ctx, input }) => {
      // FIXED: Determine the actual tenant ID to use
      let filterTenantId: string | undefined;

      if (ctx.isAdmin) {
        filterTenantId = input.tenantId;
      } else {
        if (input.tenantId && input.tenantId !== ctx.tenantId) {
          throw new Error("Unauthorized: Cannot access other tenant's data");
        }
        filterTenantId = ctx.tenantId || undefined;
      }

      try {
        // Build base where clause for endpoint filtering
        const endpointWhere: any = {};
        if (filterTenantId) {
          endpointWhere.tenantId = filterTenantId;
        }

        // Get vulnerability counts by status
        const severityCounts = await ctx.db.endpointVulnerability.groupBy({
          by: ["status"],
          where: {
            endpoint: endpointWhere,
          },
          _count: true,
        });

        // Get vulnerability counts by severity for open vulnerabilities
        const severityBreakdown = await ctx.db.vulnerability.groupBy({
          by: ["severity"],
          where: {
            endpoints: {
              some: {
                endpoint: endpointWhere,
                status: "OPEN",
              },
            },
          },
          _count: true,
        });

        // Get recent vulnerabilities (last 30 days)
        const recentVulns = await ctx.db.endpointVulnerability.count({
          where: {
            endpoint: endpointWhere,
            detectedAt: {
              gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
            },
            status: "OPEN",
          },
        });

        // Get most affected endpoints
        const affectedEndpoints = await ctx.db.endpoint.findMany({
          where: {
            ...endpointWhere,
            vulnerabilities: {
              some: {
                status: "OPEN",
              },
            },
          },
          select: {
            id: true,
            hostname: true,
            _count: {
              select: {
                vulnerabilities: {
                  where: {
                    status: "OPEN",
                  },
                },
              },
            },
          },
          orderBy: {
            vulnerabilities: {
              _count: "desc",
            },
          },
          take: 5,
        });

        const severityMap = severityBreakdown.reduce(
          (acc, item) => {
            acc[item.severity] = item._count;
            return acc;
          },
          {} as Record<string, number>,
        );

        const statusMap = severityCounts.reduce(
          (acc, item) => {
            acc[item.status] = item._count;
            return acc;
          },
          {} as Record<string, number>,
        );

        return {
          totalOpen: statusMap.OPEN || 0,
          totalResolved: statusMap.RESOLVED || 0,
          critical: severityMap.CRITICAL || 0,
          high: severityMap.HIGH || 0,
          medium: severityMap.MEDIUM || 0,
          low: severityMap.LOW || 0,
          recentlyDetected: recentVulns,
          mostAffectedEndpoints: affectedEndpoints,
          lastUpdated: new Date(),
        };
      } catch (error) {
        console.error("Error fetching vulnerability summary:", error);
        throw new Error(`Failed to fetch vulnerability summary: ${error}`);
      }
    }),

  // Get vulnerability details
  getVulnerabilityDetails: tenantProcedure
    .input(
      z.object({
        vulnerabilityId: z.string(),
      }),
    )
    .query(async ({ ctx, input }) => {
      const vulnerability = await ctx.db.vulnerability.findUnique({
        where: {
          id: input.vulnerabilityId,
        },
        include: {
          endpoints: {
            include: {
              endpoint: {
                select: {
                  id: true,
                  hostname: true,
                  operatingSystem: true,
                  tenantId: true,
                  tenant: {
                    select: {
                      name: true,
                      slug: true,
                    },
                  },
                },
              },
            },
            where: ctx.isAdmin
              ? undefined
              : {
                  endpoint: {
                    tenantId: ctx.tenantId || undefined,
                  },
                },
          },
        },
      });

      if (!vulnerability) {
        throw new Error("Vulnerability not found");
      }

      // Check access - non-admin users can only see their tenant's endpoints
      if (!ctx.isAdmin) {
        const hasAccess = vulnerability.endpoints.some(
          (ep) => ep.endpoint.tenantId === ctx.tenantId,
        );
        if (!hasAccess) {
          throw new Error("Unauthorized: No access to this vulnerability");
        }
      }

      return vulnerability;
    }),

  // Update vulnerability status for an endpoint
  updateEndpointVulnerabilityStatus: tenantProcedure
    .input(
      z.object({
        endpointVulnerabilityId: z.string(),
        status: z.enum([
          "OPEN",
          "IN_PROGRESS",
          "RESOLVED",
          "FALSE_POSITIVE",
          "ACCEPTED_RISK",
        ]),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      // First verify the user has access to this endpoint vulnerability
      const endpointVuln = await ctx.db.endpointVulnerability.findUnique({
        where: {
          id: input.endpointVulnerabilityId,
        },
        include: {
          endpoint: {
            select: {
              tenantId: true,
            },
          },
        },
      });

      if (!endpointVuln) {
        throw new Error("Endpoint vulnerability not found");
      }

      if (!ctx.isAdmin && endpointVuln.endpoint.tenantId !== ctx.tenantId) {
        throw new Error(
          "Unauthorized: Cannot update other tenant's vulnerabilities",
        );
      }

      const updateData: any = {
        status: input.status,
      };

      if (input.status === "RESOLVED") {
        updateData.resolvedAt = new Date();
      }

      return await ctx.db.endpointVulnerability.update({
        where: {
          id: input.endpointVulnerabilityId,
        },
        data: updateData,
      });
    }),

  // Get CVE sync history (admin only)
  getSyncHistory: adminProcedure
    .input(
      z.object({
        limit: z.number().min(1).max(50).default(20),
      }),
    )
    .query(async ({ ctx, input }) => {
      return await ctx.db.syncJob.findMany({
        where: {
          source: "SENTINELONE",
          // Add additional filtering for CVE-specific sync jobs if needed
        },
        orderBy: {
          startedAt: "desc",
        },
        take: input.limit,
      });
    }),
});
