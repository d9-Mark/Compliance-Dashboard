// scripts/diagnose-cve-sync.js
// Find out why CVE sync isn't creating vulnerability records

import { PrismaClient } from "@prisma/client";
import { config } from "dotenv";

config();
const db = new PrismaClient();

async function diagnoseCVESync() {
  console.log("ðŸ” CVE Sync Diagnostic Report\n");
  console.log("=".repeat(50));

  // 1. Check what should be there
  console.log("ðŸ“Š CURRENT DATABASE STATE:");

  const vulnerabilityCount = await db.vulnerability.count();
  const endpointVulnCount = await db.endpointVulnerability.count();
  const endpointCount = await db.endpoint.count();

  console.log(`   Vulnerabilities: ${vulnerabilityCount}`);
  console.log(`   Endpoint-Vulnerability Links: ${endpointVulnCount}`);
  console.log(`   Total Endpoints: ${endpointCount}`);

  // 2. Check endpoint vulnerability counts
  console.log("\nðŸ“ˆ ENDPOINT VULNERABILITY COUNTS:");
  const endpointStats = await db.endpoint.aggregate({
    _sum: {
      criticalVulns: true,
      highVulns: true,
      mediumVulns: true,
      lowVulns: true,
    },
    _count: {
      id: true,
    },
  });

  const totalVulnCounts =
    (endpointStats._sum.criticalVulns || 0) +
    (endpointStats._sum.highVulns || 0) +
    (endpointStats._sum.mediumVulns || 0) +
    (endpointStats._sum.lowVulns || 0);

  console.log(
    `   Total vulnerability counts across all endpoints: ${totalVulnCounts}`,
  );
  console.log(`   Critical: ${endpointStats._sum.criticalVulns || 0}`);
  console.log(`   High: ${endpointStats._sum.highVulns || 0}`);
  console.log(`   Medium: ${endpointStats._sum.mediumVulns || 0}`);
  console.log(`   Low: ${endpointStats._sum.lowVulns || 0}`);

  // 3. Check endpoints with counts but no vulnerability records
  const endpointsWithCounts = await db.endpoint.findMany({
    where: {
      OR: [
        { criticalVulns: { gt: 0 } },
        { highVulns: { gt: 0 } },
        { mediumVulns: { gt: 0 } },
        { lowVulns: { gt: 0 } },
      ],
    },
    select: {
      id: true,
      hostname: true,
      tenantId: true,
      sentinelOneAgentId: true,
      criticalVulns: true,
      highVulns: true,
      mediumVulns: true,
      lowVulns: true,
      _count: {
        select: {
          vulnerabilities: true,
        },
      },
    },
    take: 10,
  });

  console.log(`\nðŸ” ENDPOINTS WITH COUNTS BUT NO VULNERABILITY RECORDS:`);
  console.log(
    `   Found ${endpointsWithCounts.length} endpoints with vulnerability counts`,
  );

  if (endpointsWithCounts.length > 0) {
    console.log("\n   Sample endpoints:");
    endpointsWithCounts.forEach((endpoint, i) => {
      const totalVulns =
        (endpoint.criticalVulns || 0) +
        (endpoint.highVulns || 0) +
        (endpoint.mediumVulns || 0) +
        (endpoint.lowVulns || 0);
      console.log(`   ${i + 1}. ${endpoint.hostname}`);
      console.log(`      Tenant ID: ${endpoint.tenantId || "NULL"}`);
      console.log(
        `      SentinelOne Agent ID: ${endpoint.sentinelOneAgentId || "NULL"}`,
      );
      console.log(`      Vulnerability Counts: ${totalVulns} total`);
      console.log(
        `      Actual Vulnerability Records: ${endpoint._count.vulnerabilities}`,
      );
      console.log(
        `      âŒ MISMATCH: ${totalVulns} counted but ${endpoint._count.vulnerabilities} records`,
      );
      console.log();
    });
  }

  // 4. Check SentinelOne API connectivity
  console.log("ðŸ”— SENTINELONE CONNECTIVITY CHECK:");

  const apiKey = process.env.SENTINELONE_API_KEY;
  const endpoint = process.env.SENTINELONE_ENDPOINT;

  if (!apiKey || !endpoint) {
    console.log("   âŒ Missing SentinelOne configuration");
    console.log(`   API Key: ${apiKey ? "Set" : "Missing"}`);
    console.log(`   Endpoint: ${endpoint ? "Set" : "Missing"}`);
  } else {
    try {
      console.log(`   Endpoint: ${endpoint}`);
      console.log(`   API Key: ${apiKey.substring(0, 10)}...`);

      // Test CVE API specifically
      const response = await fetch(
        `${endpoint}/web/api/v2.1/application-management/risks?limit=1`,
        {
          headers: {
            Authorization: `ApiToken ${apiKey}`,
            "Content-Type": "application/json",
          },
        },
      );

      if (response.ok) {
        const data = await response.json();
        console.log(
          `   âœ… CVE API accessible: ${data.pagination?.totalItems || 0} CVEs available`,
        );
      } else {
        console.log(
          `   âŒ CVE API failed: ${response.status} ${response.statusText}`,
        );
        const errorText = await response.text();
        console.log(`   Error: ${errorText.substring(0, 200)}`);
      }
    } catch (error) {
      console.log(`   âŒ Connection failed: ${error.message}`);
    }
  }

  // 5. Check endpoint mapping (SentinelOne agent IDs)
  console.log("\nðŸ”— ENDPOINT MAPPING CHECK:");

  const mappedEndpoints = await db.endpoint.count({
    where: { sentinelOneAgentId: { not: null } },
  });

  const mappingRate =
    endpointCount > 0 ? Math.round((mappedEndpoints / endpointCount) * 100) : 0;

  console.log(`   Total endpoints: ${endpointCount}`);
  console.log(`   Mapped to SentinelOne: ${mappedEndpoints}`);
  console.log(`   Mapping rate: ${mappingRate}%`);

  if (mappingRate < 50) {
    console.log(`   âš ï¸  LOW MAPPING RATE - This could cause CVE sync to fail!`);
    console.log(
      `   ðŸ’¡ Solution: Run agent sync first: npm run sync-agents-only`,
    );
  }

  // 6. Check recent sync jobs
  console.log("\nðŸ“‹ RECENT SYNC JOBS:");

  const recentSyncs = await db.syncJob.findMany({
    where: {
      source: "SENTINELONE",
    },
    orderBy: {
      startedAt: "desc",
    },
    take: 5,
  });

  if (recentSyncs.length === 0) {
    console.log("   No SentinelOne sync jobs found");
  } else {
    recentSyncs.forEach((job, i) => {
      console.log(
        `   ${i + 1}. ${job.status} - ${job.startedAt.toISOString()}`,
      );
      console.log(
        `      Records: ${job.recordsProcessed} processed, ${job.recordsCreated} created`,
      );
      if (job.errorMessage) {
        console.log(`      Error: ${job.errorMessage}`);
      }
    });
  }

  // 7. Diagnosis summary
  console.log("\nðŸŽ¯ DIAGNOSIS SUMMARY:");

  if (
    vulnerabilityCount === 0 &&
    endpointVulnCount === 0 &&
    totalVulnCounts > 0
  ) {
    console.log(
      "   âŒ ISSUE IDENTIFIED: Vulnerability counts updated but no vulnerability records created",
    );
    console.log("   ðŸ” LIKELY CAUSES:");
    console.log(
      "      1. Endpoint mapping issue (low SentinelOne agent mapping)",
    );
    console.log("      2. CVE API connection failing during sync");
    console.log(
      "      3. Database transaction rollback during vulnerability creation",
    );
    console.log("      4. Silent errors in CVE processing loop");
    console.log("\n   ðŸ’¡ RECOMMENDED FIXES:");
    console.log("      1. Check logs during CVE sync for specific errors");
    console.log("      2. Run agent sync: npm run sync-agents-only");
    console.log("      3. Test CVE sync with --dry-run flag first");
    console.log(
      "      4. Check database permissions for creating vulnerability records",
    );
  } else if (vulnerabilityCount > 0 && endpointVulnCount > 0) {
    console.log(
      "   âœ… Vulnerability data exists - check tenant filtering in UI",
    );
  } else {
    console.log("   ðŸ¤” Mixed state - manual investigation needed");
  }

  await db.$disconnect();
}

diagnoseCVESync().catch(console.error);
